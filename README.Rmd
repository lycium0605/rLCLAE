---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%",
  eval = FALSE,
  echo = TRUE
)
```

# Introduction

<!-- badges: start -->
<!-- badges: end -->

rLCLAE is a R package for implementing LCLAE (Low Coverage Local Ancestry Estimation), a composite likelihood method for estimating local ancestry from low coverage genomic data developed by Wall et al. 2016 Molecular Ecology (https://doi.org/10.1111/mec.13684). This program incorporates genotype uncertainty into local ancestry assignment (e.g., the PL values in a vcf generated by GATK), which is a ubiquitous feature of low coverage genotype calls.

rLCLAE requires data from two ancestral populations and the admixed individuals for whom we want to estimate local ancestry for in a single vcf. The program uses allele frequency differences between the two ancestral populations to estimate the likelihood that an admixed individualâ€™s ancestry in a specific window of their genome is homozygous for either ancestral population or heterozygous. Importantly, rLCLAE takes into account that genotypes from low coverage sequencing are uncertain by considering the relative probability that a given genotype call is correct. Importantly, while genotype data for any single variant from low coverage data are relatively uninformative about local ancestry, genotype data aggregated across many contiguous sites can provide extremely accurate ancestry estimates. Ancestry calls can be assembled into ancestry tracts by joining neighboring variants with the same inferred ancestry, with tract boundaries determined when contiguous variants change ancestry state.

## Installation

Currently, rLCLAE cannot be installed from [CRAN](https://CRAN.R-project.org) using:

``` r
install.packages("rLCLAE")
```

You must install the development version of rLCLAE from [GitHub](https://github.com/) using:

``` r
# install.packages("devtools")
devtools::install_github("lycium0605/rLCLAE")
```

## Example

Below is the typical pipeline for transforming biallelic genomic data in vcf format to local ancestry calls. We assume that any quality control filtering of your variant calls (e.g., GATK's recommended hard filters, minor allele frequency threshold, etc.) has already been done. Note that your vcf can contain multiple chromosomes or a single chromosome at this stage.

Before importing your genomic data into R, you must do XXX (???tell them exactly what needs to be done???) to your vcf (here, raw.vcf). We can do this using bcftools (http://www.htslib.org/doc/bcftools.html) with the following command:
`bcftools annotate -x ^INFO/DP,^FORMAT/GT,^FORMAT/AD,^FORMAT/DP,^FORMAT/GQ,^FORMAT/PL raw.vcf `>` original.vcf` (???should we name it something other than original vcf - maybe tmp.vcf? original.vcf makes it seem like you haven't done anything to it which you have...i also think it might be better to call what you're calling raw.vcf as original.vcf...???)

After your data is XXX, we will perform the following steps using rLCLAE: 1) calculate the genotype likelihoods for XXX (???all individuals? only the ancestral individuals? be a little more specific here???), 2) calculate the allele frequencies in both ancestral populations, 3) calculate the ancestral likelihood for the admixed individuals, 4) call local ancestry, and 5) generate ancestry tracts.

### 1. Calculating genotype likelihood

In this step, the genotype likelihood for XXX is calculated based on the PL value in the vcf file. \
If multiple chromosomes are detected, this function will automatically split the data into multiple genotype likelihood files, one for each chromosome, and add the chromosome name to each file (e.g., genolk_chrX).

```{r prep & genolik, eval=FALSE}

## ???I think lines 59-66 should be before the "1. Calculating genotype likelihood section" and in their own section on getting started/importing the data in R.
## After installing rLCLAE, load the rLCLAE package
library(rLCLAE)

## Preprocessing (???What exactly is this function doing? Tell your reader/user???)
preprocess(inputdir = './original.vcf',outputdir = './clean.vcf')

## Checking the clean.vcf, this step can be skipped (???Tell your reader what this function is doing. What are common things that might happen when you run this function???)
inputcheck(inputdir = './clean.vcf')

## Calculate the genotype likelihood based on PL value
## ???Need to say something about the "type" parameter here (I see that you mention it later but it doesn't help the reader/users if they don't know what it is at this step)???
genolik(inputdir = './clean.vcf', outputdir = './genolik', type = 'dip')

## ???Tell the reader/user exactly what is generated here - what is in the geno like file? how many columns? what is in each column? etc.???

```

### 2. Calculating ancestral population allele frequencies

In this step, the allele frequencies for each ancestral population are calculated based on the genotype likelihoods for ancestral individuals.\
We must define which individuals are in each ancestral population. To do so, create a text file for each ancestral population with a single line of integers separated by spaces. The first integer in the line is the total number individuals in the ancestral population followed by the order of each individual in the vcf/genolik file (the order should be the same). For example, in the file "anc1dip.txt", we'll specify that we have 5 total individuals in ancestral population 1 and they are at positions 23, 24, 25, 26, and 28 in the vcf/genolike files: `5 23 24 25 26 28`\ (???I'd also give them the option, and show an example here, how to generate this file in R???)
If you have only one type of data, you can generate one ancestral allele frequency using the following code, it will add a suffix (_hap or _dip based on data type) to the output: (??? I'm confused by this sentence - if I only have diploid data, it will automatically detect that I have diploid data and add the suffix _dip? Or do I need to define pop1_dip and pop2_dip instead of pop1_hap and pop2_hap???)

```{r ancfreq_unitype}
## For diploid data 
ancfreq(outputdir = './ancfreq',inputdir_dip = './genolik_dip_chrX',
        pop1_dip = 'anc1dip.txt',pop2_dip = 'anc2dip.txt')

## For haploid data 
ancfreq(outputdir = './ancfreq',inputdir_hap = './genolik_hap_chrX',
        pop1_hap = 'anc1hap.txt',pop2_hap = 'anc2hap.txt')

```

However, if you have two different type of data (e.g. For X chromosome, you have haploid data for male and diploid data for female), you can do either of steps below: (???What other types of data could you have? Seems like it would only be haploid vs. diploid, right? If so, let's explicitly say this instead of using "types of data" which seems a little nebulous to me???)

```{r ancfreq_bitype}

## An easy way is to input them together and three files (ancfreq_dip, ancfreq_hap, ancfreq_merge) will be generated
ancfreq(outputdir = './ancfreq',
        inputdir_hap = './genolik_hap_chrX',
        pop1_hap = 'ref1hap.txt',pop2_hap = 'ref2hap.txt',
        inputdir_dip = './genolik_dip_chrX',
        pop1_dip = 'ref1dip.txt',pop2_dip = 'ref2dip.txt',
        mergetype = "union")

## Or you can use this function after calculating ancestry for both data types separately 
mergefreq(hap = './ancfreq_hap', dip = './ancfreq_dip', 
          merge = './ancfreq_merge', type = 'union')

## ???Again, tell the reader/user exactly what is generated here - what is in the ancfreq_dip file? how many columns? what is in each column? etc.???

```

`mergetype` has several options:\
`union`: Keep the snps that appear in either the diploid or haploid data.\
`intersect`: Keep the snps that appear in both the haploid and diploid data.\
`full_hap`: Keep all the snps that appear in the haploid data.\
`full_dip`: Keep all the snps that appear in the diploid data.\
After the ancfreq file is generated, you might want to check the distribution of allele frequency differences between your two ancestral populations.

```{r ancfreq_summary}

# Plot a histogram of allele frequency differences between the two ancestral populations and the mean/median/max/min of these data, and you can do further analysis on diff if necessary (???Not sure what "and you can do further analysis on diff if necessary" means - what kind of analysis would they do???)

diff<-freqsum('./ancfreq_dip')
```

### 3. Calculating the ancestry likelihood

In this step, the ancestry likelihood for each snp in each individual is calculated. The default option performs this step for all individuals in the genolik file at once. A suffix of individual index will be added to each file (e.g., anclik_1 for individual 1).

```{r anclik}

## For all individuals
anclik(genodir = './genolik_chrX', ancfreqdir = './ancfreq_merge',
       outputdir = './anclik', type = 'dip', test = 'all')

## For a specific individual: individual at position 1 in the vcf/genolik file
anclik(genodir = './genolik_chrX', ancfreqdir = './ancfreq_merge',
       outputdir = './anclik', type = 'dip', test = 1) #???Is this correct???
## For a subset of individuals (individuals 1, 2, 5, and 9 in the vcf/genolik file):
## sub<-c(1,2,5,9)
## test = sub
anclik(genodir = './genolik_chrX', ancfreqdir = './ancfreq_merge',
       outputdir = './anclik', type = 'dip', test = sub) #???Is this correct???
```

### 4. Estimating local ancestry

In this step, the ancestry state at each snp for each individual is estimated based on majority rule (???Need to explain what majority rule is???). The function, anccall, will output a data frame where each row corresponds to XXX. The first column corresponds to the snp position and the second column corresponds to the ancestry state called for that snp where a value of 0 corresponds to homozygous ancestry for ancestral population 1, 1 corresponds to heterozygous ancestry, and 2 corresponds to homozygous ancestry for ancestral population 2. (???Good - this should be included also for steps 1-3???)

```{r anccall}
# delta: the minimum ancestral allele frequency difference for snps which will be evaluated; e.g., delta=0.2 will only evaluate snps with at least a 20% allele frequency difference between ancestral populations (??? Is it >20% or >=20%???)
# window_size: the size (in base pairs) for the sliding window used in ancestry calling where the larger this value is, the shorter tracts will be smoothed out; e.g., window_size=50000 will use 50 kb sliding windows
anccall(delta = 0.2, window_size = 50000,
        inputdir = './anclik_1', outputdir = './anccall_1')
```

### 5. Generating ancestry tracts

In this step, neighboring snps with the same inferred ancestry stats can be assembled into ancestry tracts. The gettract command will generate two output files, one with a suffix of '.MajorityRule.txt' and one with '.tracts.txt'. (???Again, tell the reader/user exactly what is generated in each of these files here - what are the rows and columns in each output file? Also, how is the MajorityRule.txt file here different from the output file generated in the previous step because you say in that step that you're generating majority rule calls there???)

```{r call2tract}
gettract('./anccall_1', # input dir
         './tract_1', # output dir
         indiv_name = '1', # individual name, will add a column (???Is there a way to do it for all individuals in the sample and not each individual in turn???)
         chr='chrX', # chromosome name, will add a column
         chrlength='142711496', #chromosome length in bp
         value=35000, # window size
         mode_n=0.5, # the minimum percentage for a call to be made using majority rule
         min_n=20, # the minimum number of SNPs within the window to make a call
         exclude=50000) # how much of the start/end of each chromosome to ignore if any (???Can you do exclude=0 if you don't want to ignore anything???)
```
